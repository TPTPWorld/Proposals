<!doctype html>
<html lang=en>
<head>
<meta charset=utf-8>
<title>Algebraic Data Types</title>
</head>
<body align=JUSTIFY>
<hr> <!-- ------------------------------------------------------------------------------------- -->
<h1>Algebraic Data Types</h1>
by Michael Rawson, Geoff Sutcliffe, and Petra Hozzov&aacute;.

<!--
Geoff and Michael's thoughts for people to ask for opinion:
Jasmin & MartinD, Dimitry Traytel, Andrei Paskevich
Guillaume Bury, David Cok, Viktor Kuncak
Simon Guilloud, Sankalp Gambir, Florian Rabe
-->
<hr> <!-- ------------------------------------------------------------------------------------- -->
<h2>Background</h2>

<em>Algebraic data types</em> (ADTs, see also: <em>term algebras</em>, <em>inductive data 
types</em>, and <em>Herbrand universes</em>. 
Not to be confused with <a href="https://en.wikipedia.org/wiki/Abstract_data_type">
Abstract Data Types</a>.) are sorts with a specific interpretation.
Members of the sort are built from a fixed set of user-provided <em>constructors</em>.
ADTs are useful for representing objects from functional programming such as lists or trees, and 
also from mathematics, such as the natural numbers.
See elsewhere 
[<a href="https://tptp.org/cgi-bin/SeeTPTP?Category=BibTeX&File=KRV17">KRV17</a>,
 <a href="https://tptp.org/cgi-bin/SeeTPTP?Category=BibTeX&File=BPR18">BPR18</a>] for more 
background material on ADTs in the context of ATP.

<!-- ------------------------------------------------------------------------------------- -->
<h3>Definition</h3>

An ADT <em>A</em> is defined by a finite non-empty set of constructors.
Each constructor <em>C</em> maps zero or more arguments of any type (including <em>A</em>) into 
<em>A</em>.
The sort <em>A</em> is inhabited only by terms induced by these constructors.
Each term is distinct from any other.
<em>A</em> must be non-empty, as usual.

<!-- ------------------------------------------------------------------------------------- -->
<h3>Properties</h3>

The definition leads to several well-known properties, including the popular 
[<a href="https://tptp.org/cgi-bin/SeeTPTP?Category=BibTeX&File=KRV17">KRV17</a>] scheme:
<ul>
 <li><em>domain closure</em>: every element is constructed from one of the constructors
 <li><em>distinctness</em>: terms with different constructors are never equal to each other
 <li><em>injectivity</em>: constructors are injective functions
 <li><em>acyclicity</em>: no term can be a strict subterm of itself
</ul>

<!-- ------------------------------------------------------------------------------------- -->
<h3>Examples</h3>
The natural numbers 0, 1, 2, 3... can be defined as a sort where every term is either
<ul>
 <li><code>zero</code>, or
 <li><code>succ(N)</code>, where N is itself a natural number.
</ul>
<p>
<code>succ</code> could be read as "successor", N + 1, so that 0 is defined as <code>zero</code>, 
1 as <code>succ(zero)</code>, 2 as <code>succ(succ(zero))</code>, and so on.
<p>
In a similar way, lists can be defined as either the <code>nil</code> list or a <code>cons</code>
cell containing an element and the tail of a list.
This is a natural example of a polymorphic datatype, as the element sort is not provided.
<p>
ADTs are often (but not always) self-referential, in the sense that larger terms are built from 
smaller terms of the same sort and an appropriate constructor.

<hr> <!-- ------------------------------------------------------------------------------------- -->
<h2>Proposal by Example</h2>

The typed first-order (TFF) and higher-order (THF) languages of the TPTP will be augmented with 
ADTs.
The existing syntax is reused as far as possible so that new syntax, cognitive load, and 
implementation effort are minimised.
The new syntax and semantics are introduced by example.
<P>
Consider the natural numbers as defined above.
<pre>
tff(nat_type, type-datatype, nat : $tType).
tff(zero_type, type-datatype_constructor, zero : nat).
tff(succ_type, type-datatype_constructor, succ : nat > nat).
</pre>
<b>TODO</b> consider shorter role names: <code>type-adt</code> and <code>type-adtc</code>?
<p>
Here the type of natural numbers and two constructors are defined.
Note the use of the sub-roles <code>datatype</code> and <code>datatype_constructor</code> of the 
existing <code>type</code> role.
This indicates to the theorem prover that the type declaration should be considered an ADT or 
an ADT constructor, respectively.
<p>
ADT <em>testers</em> and <em>destructors</em> must be (for now at least ... read more below)
defined in the language itself, e.g.:
<pre>
%----check for zero
tff(is_zero_type,type,
    is_zero: nat > $o ).

tff(zero_is_zero,axiom,
    is_zero(zero) ).

tff(succ_is_not_zero,axiom,
    ! [X: nat] : ~ is_zero(succ(X)) ).

%----check for successor
tff(is_succ_type,type,
    is_succ: nat > $o ).

tff(zero_is_not_succ,axiom,
    ~ is_succ(zero) ).

tff(succ_is_succ,axiom,
    ! [X: nat] : is_succ(succ(X)) ).

%----get the predecessor of a number, if it exists
tff(pred_type,type,
    pred: nat > nat ).

tff(pred_succ,axiom,
    ! [X: nat] : ( pred(succ(X)) = X ) ).
</pre>
<p>
Note that <code>pred</code> is a <code>type</code>, not a 
<code>type-datatype_constructor</code>, i.e., it is a uninterpreted function, not part of the ADT.
At present testers and destructors are provided by the user, but a future proposal might add
defined predicates to add these automatically.
<p>
With this, it is possible to give a conjecture that is provable only with ADT semantics, e.g.,
<pre>
tff(all_nats_zero_or_succ, conjecture, ![X : nat]: is_zero(X) | is_succ(X)).
</pre>
<p>
This relies on the theorem prover reasoning that all natural numbers are either zero or the 
successor of a natural number.
Similarly:
<pre>
tff(no_cyclic_nats, conjecture, ~?[X : nat]: X = succ(X)).
tff(succ_injective, conjecture, ![X : nat, Y : nat]: X != Y => succ(X) != succ(Y)).
</pre>
<p>
These are not theorems without ADT semantics.
<P>
Mutually-recursive ADTs are allowed, but they require a particular order of declaration in order to avoid undeclared types.
Consider enforcing colour alternation in red-black trees:
<pre>
/* Corresponds to Standard ML
datatype 'a red =
    rLeaf of 'a
  | rBranch of 'a black * 'a black
and      'a black =
    bLeaf of 'a
  | bBranch of 'a red * 'a red
*/

%----declare types first
tff(red_type,type-datatype,
    red: $tType > $tType ).

tff(black_type,type-datatype,
    black: $tType > $tType ).

%----types have been declared now, any order works
tff(rLeaf_type,type-datatype_constructor,
    rLeaf: 
      !>[A: $tType] : ( A > red(A) ) ).

tff(rBranch_type,type-datatype_constructor,
    rBranch: 
      !>[A: $tType] : ( ( black(A) * black(A) ) > red(A) ) ).

tff(bLeaf_type,type-datatype_constructor,
    bLeaf: 
      !>[A: $tType] : ( A > black(A) ) ).

tff(bBranch_type,type-datatype_constructor,
    bBranch: 
      !>[A: $tType] : ( ( red(A) * red(A) ) > black(A) ) ).
</pre>

Some conjectures require the theorem prover to reason inductively, e.g.,
<pre>
tff(add_type,type,
    plus: ( nat * nat ) > nat ).

tff(add_zero,axiom,
    ! [X: nat] : ( plus(X,zero) = X ) ).

tff(add_succ,axiom,
    ! [X: nat,Y: nat] : ( plus(X,succ(Y)) = succ(plus(X,Y)) ) ).

tff(add_commutative,conjecture,
    ! [X: nat,Y: nat] : ( plus(X,Y) = plus(Y,X) ) ).
</pre>
<p>
It is possible to combine ADTs with other parts of TPTP such as arithmetic, e.g.,
<pre>
tff(nat2int_type,type,
    nat2int: nat > $int ).

tff(nat2int_zero,type,
    nat2int(zero) = 0 ).

tff(nat2int_succ,type,
    ! [X: nat] : ( nat2int(succ(X)) = $sum(nat2int(X),1) ) ).
</pre>
<b>TODO</b> more examples with e.g. HOL, FOOL, non-classical?

<hr> <!-- ------------------------------------------------------------------------------------- -->
<h2>Proposal by Syntax</h2>

<h3>The <code>type-datatype</code> Role</h3>

A new ADT <code>a_type</code> is introduced in the same way as an uninterpreted type, 
i.e. a <code>type</code> declaration that declares a <code>$tType</code>, and extends it with
the <code>datatype</code> subrole to signal the ADT semantics.
Systems should process this in the same way as a <code>type</code> declaration, but internally
flag the type as an ADT.
For example:
<pre>
tff(int_list_type, type-datatype, int_list : $tType).
</pre>

ADTs can be polymorphic, and this is also supported in TPTP by declaring a type constructor:
<pre>
tff(list_type, type-datatype, list : $tType > $tType).
</pre>

<!-- ------------------------------------------------------------------------------------- -->
<h3>The <code>type-datatype_constructor</code> Role</h3>

ADT constructors are introduced in the same way as an uninterpreted function, i.e. a 
<code>type</code> declaration that declares the signature of the constructor, and extends it with
the <code>datatype_constructor</code> subrole to signal the ADT semantics.
Systems should process this in the same way as a <code>type</code> declaration, but internally
flag the symbol as an ADT constructor.
For example:
<pre>
tff(int_nil_type, type-datatype_constructor, int_nil : int_list).
tff(int_cons_type, type-datatype_constructor, int_cons : ( $int * int_list ) > int_list).
</pre>

Polymorphism works naturally:
<pre>
tff(nil_type, type-datatype_constructor, nil : !>[A : $tType]: A > list(A)).
tff(cons_type, type-datatype_constructor, cons : !>[A : $tType]: A * list(A) > list(A)).
</pre>

<p>
The associated ADT for a constructor can be determined uniquely by the type constructor it maps 
into.
The ADT should have been declared with <code>type-datatype</code>, and systems should report 
<code>SZS status SemanticError</code> if it is not.
In the polymorphic case, it is malformed for a <code>type-datatype_constructor</code> to map into 
a type variable, and systems should likewise report <code>SemanticError</code> on inputs of the 
form:
<pre>
tff(who_do_I_belong_to, type-datatype_constructor, confused : !>[X : $tType]: X).
</pre>

Type variables should generally be repeated verbatim in the constructors of polymorphic ADTs:
<pre>
/* Below corresponds to Rocq
Inductive sum (A B:Type) : Type :=
  | inl : A -> sum A B
  | inr : B -> sum A B.
*/

%----OK
tff(sum_type,type-datatype,
    sum: ( $tType * $tType ) > $tType ).

tff(inl_type,type-datatype_constructor,
    inl: 
      !>[A: $tType,B: $tType] : ( A > sum(A,B) ) ).

tff(inr_type,type-datatype_constructor,
    inr: 
      !>[A: $tType,B: $tType] : ( B > sum(A,B) ) ).

%----probably not intended but permissible
tff(sum_type_001,type-datatype,
    sum: ( $tType * $tType ) > $tType ).

tff(inl_type_002,type-datatype_constructor,
    inl: 
      !>[A: $tType,B: $tType] : ( B > sum(B,A) ) ).

tff(inr_type_003,type-datatype_constructor,
    inr: 
      !>[A: $tType,B: $tType] : ( A > sum(B,A) ) ).
</pre>

Renaming or instantiating sort variables in the range of a constructor is not necessarily an error (see <a href="#GADTs">Generalized ADTs</a> below) 
and systems that do not support such deviations should report 
<code>SZS status Inappropriate</code>.
<P>
A datatype and its constructors must be declared contiguously (so that an ATP system knows
when it has read all the constructors (because it reads a non-constructor)).
Mutually recursive ADTs must be declared contiguously, first the <TT>datatype</TT>s, then
all the <TT>datatype_constructor</TT>s.

<!-- ------------------------------------------------------------------------------------- -->
<h3 id="inhabitation">Checking for Inhabited Sorts</h3>

ADTs <b>must</b> have at least one inhabitant, otherwise all bets are off and systems are allowed
to be unsound, incomplete, or both.
Systems are unlikely to check this in all cases, as checking inhabitation is hard in the presence
of, e.g., polymorphism with nested datatypes [<A HREF="http://tptp.org/cgi-bin/SeeTPTP?Category=BibTeX&File=Gun93">Gun93</A>, <A HREF="http://tptp.org/cgi-bin/SeeTPTP?Category=BibTeX&File=TPB12">TPB12</A>].
If a system does detect that a sort is uninhabited, it should report <code>SZS status SemanticError</code> 
and a suitable message.  
For example, both types in:
<pre>
tff(void_type, type-datatype, void : $tType).

tff(list_type, type-datatype, list : $tType > $tType).
%----whoops, forgot nil
tff(cons_type, type-datatype_constructor, cons : !>[A : $tType]: (A * list(A)) > list(A)).
</pre>
might (or might not) trigger an error.
Users who create problems with ADTs should ensure that their ADTs are inhabited.
Problems in the TPTP library declare only inhabited ADTs.

<hr> <!-- ------------------------------------------------------------------------------------- -->
<h2>Problems and Systems</h2>

A new tag will be added to the SPC of problems in the TPTP library that use ADTs,
either <TT>ADT</TT> or <TT>NAT</TT>
<P>
Problems can be imported from existing libraries, including TIP [<a href="https://tptp.org/cgi-bin/SeeTPTP?Category=BibTeX&File=CJ+15">CJ+15</a>] and Vampire's <a href="https://github.com/vprover/inductive_benchmarks">inductive benchmarks</a>. ITP systems are likely to produce ADT inputs if the language supports it.
<p>
Systems are presently more sparse. Vampire supports much of this proposal already, but will need adapting for the new syntax. Some SMT solvers support a theory of data types, including Z3 and cvc5.
<P>
Existing theorem provers might treat the new <code>type</code> subroles as normal 
<code>type</code> declarations.
This will <em>reduce</em> the logical strength of the input, which might result in a 
previously-complete system claiming that theorem is a non-theorem.
Systems affected by this could:
<ul>
 <li> report <code>SZS status Inappropriate</code> on encountering one of the new 
      <code>type</code> subroles; or
 <li> treat the symbols as uninterpreted, reporting incompleteness where appropriate; or
 <li> implement support for ADTs
</ul>
in ascending order of preference. ;-)

<hr> <!-- ------------------------------------------------------------------------------------- -->
<h2>Advanced Topics</h2>

The above should suffice for the casual user and implementer of ADTs.
However, there are some interesting corners that merit further discussion.

<!-- ------------------------------------------------------------------------------------- -->
<h3>Induction</h3>

Some ADT theorems might require the system to employ inductive reasoning, or similar techniques.
Neither TPTP syntax nor semantics make any reference to this: induction is a system-level technique 
that is independent of ADTs (and might be applied in a non-ADT context).

Reminder for Geoff: there are some problems expressible in first-order syntax that are not "plain" 
first-order theorems but are theorems <b>with additional (theory) semantics</b>, like 2 + 2 = 4.
Systems that use induction should report induction schemata, in the same way as theory axioms in 
proofs.

<!-- ------------------------------------------------------------------------------------- -->
<h3>ADTs and Higher-Order Logic</h3>

Constructors with a function type in their domain are legal.
Consider the following embedding of simply-typed &lambda;-calculus into HOL using higher-order abstract syntax:
<pre>
/*
Following corresponds to the Standard ML
datatype 'a expr =
    eVar of 'a
  | eApp of 'a expr * 'a expr
  | eLam of 'a -> 'a expr
*/

thf(expr_type,type-datatype,
    expr: $tType > $tType ).

thf(eVar_type,type-datatype_constructor,
    eVar: 
      !>[A: $tType] : ( A > expr(A) ) ).

thf(eApp_type,type-datatype_constructor,
    eApp: 
      !>[A: $tType] : ( ( expr(A) * expr(A) ) > expr(A) ) ).

thf(eLam_type,type-datatype_constructor,
    eLam: 
      !>[A: $tType] : ( ( A > expr(A) ) > expr(A) ) ).
</pre>

However, not all such datatypes are meaningful 
[<A HREF="http://tptp.org/cgi-bin/SeeTPTP?Category=BibTeX&File=Pau00">Pau00</A>] and some may 
introduce inconsistencies or surprising results. Consider

<pre>
/*
Below corresponds loosely to (illegal) Rocq

Inductive dodgy :=
  bites : (dodgy -> Prop) -> dodgy.
*/

thf(dodgy_type, type-datatype, dodgy : $tType).
thf(dont_trust_it_bites, type-datatype-constructor, bites : (dodgy > $o) > dodgy).
</pre>

With the standard semantics for higher-order logic, this declaration alone has no models, as there would then be a bijection between <tt>dodgy</tt> and <tt>dodgy > $o</tt>.
In the same spirit as <a href="#inhabitation">sort inhabitation</a>, users should not supply such declarations, and systems may behave strangely if they do. Systems may choose to check for these, perhaps implementing a condition such as <em>strict positivity</em>.
Problems in the TPTP library declare only well-behaved higher-order datatypes.

<p>
<b>Thanks to <a href="https://simonguilloud.ch/">Simon Guilloud</a>, <a href="https://people.epfl.ch/sankalp.gambhir">Sankalp Gambhir</a> and others at EPFL for raising this concern and producing the example!</b>

<!-- ------------------------------------------------------------------------------------- -->
<h3 id="GADTs">Generalized ADTs</h3>

The proposed syntax permits a polymorphic ADT with constructors that instantiate (or permute) arguments of the type constructor in their range.
This is what functional programmers refer to as <a href="https://wiki.haskell.org/Generalised_algebraic_datatype"><em>Generalized</em> ADTs</a>.
There is no reason to forbid this in TPTP, but system support is likely to be patchy.

<!-- ------------------------------------------------------------------------------------- -->
<h3>Dependently-Typed ADTs</h3>

ADTs can also be dependently-typed, incluing the well-known 'vector' example.
<pre>
tff(vec_type,type-datatype,
    vec: ( nat * $tType ) > $tType ).

tff(nil_type,type-datatype_constructor,
    nil: 
      !>[A: $tType] : vec(zero,A) ).

tff(cons_type,type-datatype_constructor,
    cons: 
      !>[N: nat,A: $tType] : ( ( A * vec(N,A) ) > vec(succ(N),A) ) ).
</pre>
<b>TODO</b> check this with Cezary?

<!-- ------------------------------------------------------------------------------------- -->
<h3>Codatatypes</h3>

This proposal deliberately does not include co-datatypes.
Codatatypes are a similar concept and will likely use similar syntax in a future proposal.
Systems that implement codatatypes as an extension should use the datatype syntax as a starting point to minimise later effort.
These might be proposed in future, but to keep this proposal manageable the scope is limited.

<hr> <!-- ------------------------------------------------------------------------------------- -->
</body>
</head>
